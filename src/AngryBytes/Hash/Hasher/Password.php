<?php
/**
 * Password.php
 *
 * @category        AngryBytes
 * @package         Hash
 * @subpackage      Hasher
 * @copyright       Copyright (c) 2007-2016 Angry Bytes BV (http://www.angrybytes.com)
 */

namespace AngryBytes\Hash\Hasher;

use AngryBytes\Hash\HasherInterface;

use \InvalidArgumentException;
use \RuntimeException;

/**
 * Password Hasher Using Native PHP Hash Methods
 *
 * Generate and verify hashes using the `password_*` functions.
 * The hashing algorithm and salting is handled by these functions.
 *
 * @category        AngryBytes
 * @package         Hash
 * @subpackage      Hasher
 */
class Password implements HasherInterface
{
    /**
     * Cost factor for the algorithm
     *
     * @var int
     */
    private $cost;

    /**
     * Password constructor.
     *
     * @param null|int $cost
     */
    public function __construct($cost = null)
    {
        $this->setCost($cost);
    }

    /**
     * {@inheritDoc}
     *
     * Supported options in $options array:
     * - 'salt': Override the salt generated by password_hash() (discouraged)
     * - 'cost': Override the default cost (not advised)
     *
     * @throws RuntimeException If the hashing fails
     */
    public function hash($data, array $options = [])
    {
        $hash = password_hash($data, PASSWORD_DEFAULT, $this->parsePasswordOptions($options));
        if ($hash === false) {
            throw new RuntimeException('Failed to hash password');
        }

        return $hash;
    }

    /**
     * {@inheritDoc}
     */
    public function verify($string, $hash, array $options = [])
    {
        return password_verify($string, $hash);
    }

    /**
     * Determine if the password needs to be rehashed based on the hash options
     *
     * If true, the password should be rehashed after verification.
     *
     * @param string $hash
     * @param array $options Password options, @see hash()
     * @return bool
     */
    public function needsRehash($hash, array $options = [])
    {
        return password_needs_rehash($hash, PASSWORD_DEFAULT, $this->parsePasswordOptions($options));
    }

    /**
     * Get info for the given hash
     *
     * @see password_get_info()
     * @param string $hash
     * @return mixed[]
     */
    public function getInfo($hash)
    {
        return password_get_info($hash);
    }

    /**
     * Set cost
     *
     * @throws InvalidArgumentException if the cost is too high or low
     * @param int|null $cost
     */
    public function setCost($cost)
    {
        if (is_null($cost)) {
            $this->cost = $cost;

            return;
        }

        if ($cost < 4 || $cost > 31) {
            throw new InvalidArgumentException(sprintf(
                'Cost value "%d" needs to be greater than 3 and smaller than 32', (int) $cost
            ));
        }

        $this->cost = (int) $cost;
    }

    /**
     * Parse password options for hash methods
     *
     * @param array $options
     * @return array
     */
    private function parsePasswordOptions(array $options)
    {
        // Parse options
        if (!isset($options['cost']) && is_int($this->cost)) {
            $options['cost'] = $this->cost;
        }

        return $options;
    }
}
